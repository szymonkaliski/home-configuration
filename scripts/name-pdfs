#!/usr/bin/env bash

set -euo pipefail

if [ "$#" -eq 0 ]; then
    echo "Usage: $(basename "$0") <pdf_file1> [pdf_file2 ...]"
    echo "Rename PDFs to 'Title - Subtitle.pdf' format using AI"
    exit 1
fi

# Results tracking
declare -a results

echo "Processing PDF files..."
echo ""

pdf_count=0
success_count=0
skip_count=0
fail_count=0

for pdf_file in "$@"; do
    if [ ! -f "$pdf_file" ]; then
        results+=("✗ $pdf_file - file not found")
        fail_count=$((fail_count + 1))
        continue
    fi

    if [[ ! "$pdf_file" =~ \.pdf$ ]]; then
        results+=("✗ $pdf_file - not a PDF file")
        fail_count=$((fail_count + 1))
        continue
    fi

    pdf_count=$((pdf_count + 1))
    echo "[$pdf_count/$#] Processing: $(basename "$pdf_file")"

    # Extract metadata and text
    metadata=$(pdfinfo "$pdf_file" 2>/dev/null || echo "No metadata available")
    text_content=$(pdftotext -l 3 "$pdf_file" - 2>/dev/null | head -500 || echo "Could not extract text")

    # Get absolute path
    abs_path=$(realpath "$pdf_file")
    dir=$(dirname "$abs_path")
    current_name=$(basename "$abs_path")

    # Create temp file with the prompt
    temp_prompt=$(mktemp)
    cat > "$temp_prompt" << 'PROMPT_END'
Based on the PDF metadata and extracted text below, suggest a proper academic paper filename in the format "Title - Subtitle.pdf".

Rules:
1. Use proper title case
2. If there's a clear subtitle, include it after " - "
3. If no subtitle, just use "Title.pdf"
4. Remove special characters that are problematic in filenames (keep only: a-zA-Z0-9 spaces - _ .)
5. Keep the name concise but descriptive
6. Ensure the .pdf extension is included

IMPORTANT: Output ONLY the new filename, nothing else. No explanations, no commands, just the filename.

PROMPT_END

    # Add the file data
    {
        echo "CURRENT FILE: $current_name"
        echo "DIRECTORY: $dir"
        echo ""
        echo "PDF METADATA:"
        echo "$metadata"
        echo ""
        echo "EXTRACTED TEXT (first pages):"
        echo "$text_content"
    } >> "$temp_prompt"

    # Send to Claude and capture output
    new_name=$(cat "$temp_prompt" | claude --print --dangerously-skip-permissions 2>/dev/null || echo "")

    # Clean up temp file
    rm -f "$temp_prompt"

    # Clean up the output (remove any leading/trailing whitespace)
    new_name=$(echo "$new_name" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

    # Check if we got a valid filename
    if [[ -z "$new_name" || "$new_name" == "$current_name" || ! "$new_name" =~ \.pdf$ ]]; then
        results+=("⊘ $current_name - couldn't determine new name")
        skip_count=$((skip_count + 1))
    else
        # Construct full paths
        old_path="$abs_path"
        new_path="$dir/$new_name"

        # Attempt rename
        if [ "$old_path" != "$new_path" ]; then
            mv "$old_path" "$new_path" 2>/dev/null
            if [ $? -eq 0 ]; then
                results+=("✓ $current_name -> $new_name")
                success_count=$((success_count + 1))
            else
                results+=("✗ $current_name -> $new_name - rename failed")
                fail_count=$((fail_count + 1))
            fi
        else
            results+=("⊘ $current_name - already has correct name")
            skip_count=$((skip_count + 1))
        fi
    fi
done

# Display summary
echo ""
echo "Rename Summary"
echo "=============="
echo ""

for result in "${results[@]}"; do
    echo "$result"
done

echo ""
echo "Total: $pdf_count PDFs processed"
echo "  ✓ Renamed: $success_count"
echo "  ⊘ Skipped: $skip_count"
echo "  ✗ Failed: $fail_count"

